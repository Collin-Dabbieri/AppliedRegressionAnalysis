---
title: "Functions"
author: "Collin Dabbieri"
date: "10/4/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(s20x)

```




```{r}
myy=function(x,Y,X,alpha){
  n=nrow(X)
  k=ncol(X)-1
  model=lm(Y~X[,-1])
  r=model$residuals
  coeff=model$coefficients
  yhat=coeff[1]
  for(i in 1:k){
    yhat=yhat+(coeff[i+1]*x[i])
  }

  SSE=sum(r^2)
  s=sqrt(SSE/(n-(k+1)))
  t=qt(1-alpha/2,n-(k+1))
  pm=c(-1,1)
  
  ci=yhat+pm*t*s*sqrt(1+t(x)%*%solve(t(X)%*%X)%*%x)
  
  return(list(yhat=yhat,ci=ci))
}
```


```{r}
myl=function(Y,X,alpha,a,l){
  
  n=nrow(X)
  k=ncol(X)-1
  t=qt(1-alpha/2,n-(k+1))
  pm=c(-1,1)
  
  model=lm(Y~X[,-1])
  coeff=model$coefficients
  
  betahat=matrix(data=coeff,nrow=k+1,ncol=1)
  
  coeff=model$coefficients
  r=model$residuals
  SSE=sum(r^2)
  s=sqrt(SSE/(n-(k+1)))
  
  ci=l+pm*t*s*sqrt(t(a)%*%solve(t(X)%*%X)%*%a)

  return(list(ci=ci))
  
}
```



```{r}
myCIforl=function(alpha,betahat,X,a,s){
  plusminus=c(-1,1)
  n=nrow(X)
  k=ncol(X)-1

  ci=t(a)%*%betahat+plusminus*qt(1-alpha/2,n-(k+1))*s*sqrt(t(a)%*%solve(t(X)%*%X)%*%a)

  return(list(ci=ci))
}
```


```{r}
mycip=function(x,n,alpha){
  phat=x/n
  z=qnorm(1-alpha/2,0,1)
  mp=c(-1,1)
  #less constraining approximation
  ci1=phat+mp*z*sqrt(phat*(1-phat)/n)
  
  #more rigorous version worked out above
  ci2=(phat+z^2/(2*n))/(1+z^2/n)+mp*((z)/(1+z^2/n))*sqrt((phat*(1-phat))/(n)+(z^2)/(4*n^2))
  
  return(list(ci1=ci1,ci2=ci2))
}
```


```{r}
mypipj = function(tab,ni,nj,alpha=0.05) #tab = table
{
  total_points=sum(tab)
  ci_matrix_lower=array(dim=c(length(tab),length(tab)))
  ci_matrix_upper=array(dim=c(length(tab),length(tab)))
  pt_est_matrix=array(dim=c(length(tab),length(tab)))
  z=qnorm(1-alpha/2,0,1)
  for (i in 1:length(tab)){
    for (j in 1:length(tab)){
      if (i==j){
        
      }
      else{
        pihat=tab[i]/total_points
        pjhat=tab[j]/total_points
        pt_est=pihat-pjhat
        pt_est_matrix[i,j]=pt_est
      
        radicand=(pihat*(1-pihat)+pjhat*(1-pjhat)+2*pihat*pjhat)/(total_points)
        lower=pt_est-z*sqrt(radicand)
        upper=pt_est+z*sqrt(radicand)
        ci=c(lower,upper)
        ci_matrix_lower[i,j]=lower
        ci_matrix_upper[i,j]=upper
        
      }

      
    }
    
  }
  
  dimnames(ci_matrix_lower) = list( c("A", "B","C","D","E"),c("A","B","C","D","E"))
  dimnames(ci_matrix_upper) = list( c("A", "B","C","D","E"),c("A","B","C","D","E")) 
  dimnames(pt_est_matrix) = list( c("A", "B","C","D","E"),c("A","B","C","D","E"))

  
  
  # Now create colored barplot with hypothesis values and sample values
  num_categories=length(tab)
  hypoth_val=1./num_categories
 
  
  true_vals=c()
  for (i in 1:num_categories){
    ptemp=tab[i]/total_points
    true_vals=append(true_vals,ptemp)
  }

  
  barplot(rbind(true_vals,hypoth_val),beside=TRUE,legend = c("sample", "hypothesis"),xlab="Categories",ylab="Proportion",col=c('lightblue','magenta'))
  
  return(list(ci_lower_bound=ci_matrix_lower,ci_upper_bound=ci_matrix_upper,pt_est=pt_est_matrix))
  
}
```



